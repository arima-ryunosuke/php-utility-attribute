<?php
namespace demo;

require_once __DIR__ . '/../vendor/autoload.php';

use Attribute;
use JsonSerializable;
use ryunosuke\utility\attribute\Attribute\AbstractAttribute;
use ryunosuke\utility\attribute\Attribute\DebugInfo;
use ryunosuke\utility\attribute\Attribute\Friend;
use ryunosuke\utility\attribute\Attribute\Json;
use ryunosuke\utility\attribute\ClassTrait\DebugInfoTrait;
use ryunosuke\utility\attribute\ClassTrait\FriendTrait;
use ryunosuke\utility\attribute\ClassTrait\JsonTrait;
use ryunosuke\utility\attribute\ReflectionAttribute;

#[Attribute(Attribute::TARGET_ALL)]
class SampleAttribute1 extends AbstractAttribute
{
    public function __construct(int $a, $b = 2, $c = 3) { }
}

#[Attribute(Attribute::TARGET_ALL)]
class SampleAttribute2 extends AbstractAttribute
{
}

/**
 * below comment is autogenerated by annotate.
 *
 * @auto-document-Friend:begin
 * @property int $privateField
 * @auto-document-Friend:end
 */
#[SampleAttribute1(1, c: 9)]
class SampleClass implements JsonSerializable
{
    use DebugInfoTrait;
    use FriendTrait;
    use JsonTrait;

    #[Friend]
    #[DebugInfo(false), Json(true)]
    private int $privateField = 123;

    #[Json(false)]
    public int $publicField = 456;

    #[SampleAttribute1(1)]
    public function method()
    {
    }
}

#[SampleAttribute2]
class SampleSubClass extends SampleClass
{
    public function method() { return parent::method(); }
}

$sample    = new SampleClass();
$subsample = new SampleSubClass();

# Get attribute by following inheritance tree
var_dump(SampleAttribute1::of($subsample->method(...), 0));
var_dump(SampleAttribute1::of($subsample->method(...), ReflectionAttribute::FOLLOW_INHERITANCE));

# Get attribute by seeing class also
var_dump(SampleAttribute2::of($subsample->method(...), 0));
var_dump(SampleAttribute2::of($subsample->method(...), ReflectionAttribute::SEE_ALSO_CLASS));

# Get attribute without Reflection
var_dump(SampleAttribute1::arrayOf($sample));
# Single version above
$attr = SampleAttribute1::of($sample);

# ReflectionAttribute implements getReflection
var_dump($attr->getReflection());

# ReflectionAttribute implements getNamedArguments
var_dump($attr->getNamedArguments());
# Compare getArguments and above
var_dump($attr->getArguments());

# ReflectionAttribute implements getNamedArgument
var_dump($attr->getNamedArgument('c'));
# Same as
$params = $attr->getArguments();
var_dump(array_key_exists(2, $params) ? $params[2] : (array_key_exists('c', $params) ? $params['c'] : null));
# But native doesn't do this
var_dump($attr->getNamedArgument('b'));

# Access private field by Friend
var_dump($sample->privateField);
var_dump($subsample->privateField);

# $privateField is invisible at var_dump by DebugInfo
var_dump($sample);

# $privateField is visible/$publicField is invisible at json_encode by Json
var_dump(json_encode($sample, JSON_PRETTY_PRINT));

# Rewrite SampleClass DocComment
$sample->annotate();
